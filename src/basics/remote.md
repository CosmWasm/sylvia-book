# Remote type

Your contract may rely on communication with another one. For example, it could
`instantiate` a `CW20` contract and, during the workflow, send `Mint` messages to it. If `CW20` 
contract was created using ^sylvia, it would have a `Remote` type generated which would make this
process more user friendly.
It is possible to send queries and build `execute` messages by using `Remote`.

To check some examples, checkout the ^sylvia repository
and go to `sylvia/tests/remote.rs` and `sylvia/tests/executor.rs`.

## Working with Remote

`Remote` represents some contract instantiated on the blockchain. It aims to give contract
developers a gateway to communicate with other contracts. It has only one field, which is a remote
contract address.
There are two main methods implemented for this type:
 * `querier`, which returns a `BoundQuerier` type,
 * `executor` that returns an `ExecutorBuilder` type.

`BoundQuerier` implements `Querier` traits of every sylvia contract and interface.
`Querier` traits are auto-generated by `contract` and `interface` macros and consist
of every query method of the given contract and interface.

Similar to `BoundQuerier` and `Querier`, the `ExecutorBuilder` implements every
`Executor` trait auto-generated for sylvia contracts and interfaces. `Executor`
traits contain `exec` methods.


If we create a contract relying on our `CounterContract`, it could query its state as below.

```rust,noplayground
use sylvia::types::Remote;
use crate::whitelist::sv::Querier as WhitelistQuerier;
use crate::contract::sv::Querier as ContractQuerier;

let count = Remote::<CounterContract>::new(addr)
    .querier(&ctx.deps.querier)
    .count()?
    .count;

let admins = Remote::<CounterContract>::new(ctx.info.sender)
    .querier(&ctx.deps.querier)
    .admins()?;
```

Important to note is that `Remote` is generic over the contract type. To use it in context
of some contract, just initialize it generic over it.

In case of contract initializing the `CW20` contract you might want to keep its address in the
state.

```rust,noplayground
use sylvia::types::Remote;

struct Contract<'a> {
    cw20: Item<Remote<'a, Cw20Contract>>,
}
```

Then to query the contract load the remote, call `querier` on it which will return `BoundQuerier`
and then call the query method on it.

```rust,noplayground
self.cw20
    .load(ctx.deps.storage)?
    .querier(&ctx.deps.querier)
    .query_all_balances()?
```

Let's see an example for an `exec` method call:

```rust,noplayground
use sylvia::types::Remote;
use crate::contract::sv::Executor;

let increment_msg: WasmMsg = Remote::<CounterContract>::new(addr)
    .executor()
    .increment_count()?
    .build();
```

# Next step

Phew.. that was a journey. We learned most of the ^sylvia features and should be ready to create our first contracts.
In the last chapter, we will learn about some of the best practices that will make our code more readable and maintainable.
